{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLAlchemy-Function SQLAlchemy-Function defines a SQLALchemy Mixin for creating Function models. A Function model has a function, arguments, and keyword arguments. When called, the Function model executes its function, passing in its arguments and keyword arguments. Installation $ pip install sqlalchemy-function Quickstart In the setup, we create a SQLAlchemy session and a Function model subclassing FunctionMixin . from sqlalchemy_function import FunctionMixin, FunctionRelator # standard session creation from sqlalchemy import create_engine, Column, ForeignKey, Integer from sqlalchemy.orm import relationship, sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `FunctionMixin` to define a Function model class Function(FunctionMixin, Base): __tablename__ = 'function' id = Column(Integer, primary_key=True) Base.metadata.create_all(engine) We can now store and later call functions as follows. def foo(*args, **kwargs): print('My args are', args) print('My kwargs are', kwargs) return 'return value' func = Function(foo, 'hello world', goodbye='moon') func() Out: My args are ('hello world',) My kwargs are {'goodbye': 'moon'} 'return value' Citation @software{bowen2020sqlalchemy-function, author = {Dillon Bowen}, title = {SQLAlchemy-Function}, url = {https://dsbowen.github.io/sqlalchemy-function/}, date = {2020-06-15}, } License Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"Home"},{"location":"#sqlalchemy-function","text":"SQLAlchemy-Function defines a SQLALchemy Mixin for creating Function models. A Function model has a function, arguments, and keyword arguments. When called, the Function model executes its function, passing in its arguments and keyword arguments.","title":"SQLAlchemy-Function"},{"location":"#installation","text":"$ pip install sqlalchemy-function","title":"Installation"},{"location":"#quickstart","text":"In the setup, we create a SQLAlchemy session and a Function model subclassing FunctionMixin . from sqlalchemy_function import FunctionMixin, FunctionRelator # standard session creation from sqlalchemy import create_engine, Column, ForeignKey, Integer from sqlalchemy.orm import relationship, sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `FunctionMixin` to define a Function model class Function(FunctionMixin, Base): __tablename__ = 'function' id = Column(Integer, primary_key=True) Base.metadata.create_all(engine) We can now store and later call functions as follows. def foo(*args, **kwargs): print('My args are', args) print('My kwargs are', kwargs) return 'return value' func = Function(foo, 'hello world', goodbye='moon') func() Out: My args are ('hello world',) My kwargs are {'goodbye': 'moon'} 'return value'","title":"Quickstart"},{"location":"#citation","text":"@software{bowen2020sqlalchemy-function, author = {Dillon Bowen}, title = {SQLAlchemy-Function}, url = {https://dsbowen.github.io/sqlalchemy-function/}, date = {2020-06-15}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"License"},{"location":"function_mixin/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Function mixin sqlalchemy_function. FunctionMixin class sqlalchemy_function. FunctionMixin ( func, *args, **kwargs ) [source] A mixin for 'Function models'. When called, a Function model executes its function, passing in its arguments and keyword arguments. Parameters: func : callable or None, default=None The function which the Function model will execute when called. *args, **kwargs : Arguments and keyword arguments which the Function model will pass into its func when called. The FunctionMixin constructor will not override arguments and keyword arguments if they have already been set. Attributes: func : callable sqlalchemy.PickleType Set from the func parameter. args : sqlalchemy_mutable.MutableListType Set from the *args parameter. kwargs : sqlalchemy_mutable.MutableDictType Set from the **kwargs parameter. Examples In the setup, we create a SQLAlchemy session and a Function model subclassing FunctionMixin . from sqlalchemy_function import FunctionMixin, FunctionRelator # standard session creation from sqlalchemy import create_engine, Column, ForeignKey, Integer from sqlalchemy.orm import relationship, sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `FunctionMixin` to define a Function model class Function(FunctionMixin, Base): __tablename__ = 'function' id = Column(Integer, primary_key=True) Base.metadata.create_all(engine) We can now store and later call functions as follows. def foo(*args, **kwargs): print('My args are', args) print('My kwargs are', kwargs) return 'return value' func = Function(foo, 'hello world', goodbye='moon') func() Out: My args are ('hello world',) My kwargs are {'goodbye': 'moon'} 'return value' Methods set ( self, func, *args, **kwargs ) [source] Set the function, arguments, and keyword arguments. Parameters: func : callable or None, default=None The function which the Function model will execute when called. *args, **kwargs : Arguments and keyword arguments which the Function model will pass into its func when called. Returns: self : sqlalchemy_function.FunctionMixin __call__ ( self, *args, **kwargs ) [source] Call self.func , passing in *self.args, **self.kwargs . Additional arguments passed to self.__call__ are prepended to self.args , and additional keyword arguments update self.kwargs before passing to self.func . The function call is essentially: kwargs_ = self.kwargs.copy() kwargs_.update(kwargs) self.__call__(*args, *self.args, **kwargs_) Parameters: *args, **kwargs : Additional arguments and keyword arguments passed to self.func . Returns: output : Output of self.func . Notes If the arguments or keyword arguments contain database models, they will be 'unshelled' when they are passed into the function. See https://dsbowen.github.io/sqlalchemy-mutable/ for more detail.","title":"Function mixin"},{"location":"function_mixin/#function-mixin","text":"","title":"Function mixin"},{"location":"function_mixin/#sqlalchemy_functionfunctionmixin","text":"class sqlalchemy_function. FunctionMixin ( func, *args, **kwargs ) [source] A mixin for 'Function models'. When called, a Function model executes its function, passing in its arguments and keyword arguments. Parameters: func : callable or None, default=None The function which the Function model will execute when called. *args, **kwargs : Arguments and keyword arguments which the Function model will pass into its func when called. The FunctionMixin constructor will not override arguments and keyword arguments if they have already been set. Attributes: func : callable sqlalchemy.PickleType Set from the func parameter. args : sqlalchemy_mutable.MutableListType Set from the *args parameter. kwargs : sqlalchemy_mutable.MutableDictType Set from the **kwargs parameter.","title":"sqlalchemy_function.FunctionMixin"},{"location":"function_mixin/#examples","text":"In the setup, we create a SQLAlchemy session and a Function model subclassing FunctionMixin . from sqlalchemy_function import FunctionMixin, FunctionRelator # standard session creation from sqlalchemy import create_engine, Column, ForeignKey, Integer from sqlalchemy.orm import relationship, sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `FunctionMixin` to define a Function model class Function(FunctionMixin, Base): __tablename__ = 'function' id = Column(Integer, primary_key=True) Base.metadata.create_all(engine) We can now store and later call functions as follows. def foo(*args, **kwargs): print('My args are', args) print('My kwargs are', kwargs) return 'return value' func = Function(foo, 'hello world', goodbye='moon') func() Out: My args are ('hello world',) My kwargs are {'goodbye': 'moon'} 'return value'","title":"Examples"},{"location":"function_mixin/#methods","text":"set ( self, func, *args, **kwargs ) [source] Set the function, arguments, and keyword arguments. Parameters: func : callable or None, default=None The function which the Function model will execute when called. *args, **kwargs : Arguments and keyword arguments which the Function model will pass into its func when called. Returns: self : sqlalchemy_function.FunctionMixin __call__ ( self, *args, **kwargs ) [source] Call self.func , passing in *self.args, **self.kwargs . Additional arguments passed to self.__call__ are prepended to self.args , and additional keyword arguments update self.kwargs before passing to self.func . The function call is essentially: kwargs_ = self.kwargs.copy() kwargs_.update(kwargs) self.__call__(*args, *self.args, **kwargs_) Parameters: *args, **kwargs : Additional arguments and keyword arguments passed to self.func . Returns: output : Output of self.func .","title":"Methods"},{"location":"function_mixin/#notes","text":"If the arguments or keyword arguments contain database models, they will be 'unshelled' when they are passed into the function. See https://dsbowen.github.io/sqlalchemy-mutable/ for more detail.","title":"Notes"},{"location":"function_relator/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Function relator mixin sqlalchemy_function. FunctionRelator Base for database models with relationships to Function models. It provides automatic conversion of functions to Function models when setting attributes. Examples In the setup, we create a SQLAlchemy session, define a Parent model subclassing FunctionRelator , and a Function model subclassing FunctionMixin . from sqlalchemy_function import FunctionMixin, FunctionRelator # standard session creation from sqlalchemy import create_engine, Column, ForeignKey, Integer from sqlalchemy.orm import relationship, sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `FunctionRelator` for models with a relationship to Function models class Parent(FunctionRelator, Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) functions = relationship('Function', backref='parent') # subclass `FunctionMixin` to define a Function model class Function(FunctionMixin, Base): __tablename__ = 'function' id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey('parent.id')) Base.metadata.create_all(engine) We can now set the functions attribute to a callable as follows. def foo(*args, **kwargs): print('My args are', args) print('My kwargs are', kwargs) return 'return value' parent = Parent() parent.functions = foo # equivalent to: # parent.functions = [foo] # parent.functions = Function(foo) # parent.functions = [Function(foo)] parent.functions Out: [<__main__.Function object at 0x7f4e5a49c160>]","title":"Function relator"},{"location":"function_relator/#function-relator-mixin","text":"","title":"Function relator mixin"},{"location":"function_relator/#sqlalchemy_functionfunctionrelator","text":"Base for database models with relationships to Function models. It provides automatic conversion of functions to Function models when setting attributes.","title":"sqlalchemy_function.FunctionRelator"},{"location":"function_relator/#examples","text":"In the setup, we create a SQLAlchemy session, define a Parent model subclassing FunctionRelator , and a Function model subclassing FunctionMixin . from sqlalchemy_function import FunctionMixin, FunctionRelator # standard session creation from sqlalchemy import create_engine, Column, ForeignKey, Integer from sqlalchemy.orm import relationship, sessionmaker, scoped_session from sqlalchemy.ext.declarative import declarative_base engine = create_engine('sqlite:///:memory:') session_factory = sessionmaker(bind=engine) Session = scoped_session(session_factory) session = Session() Base = declarative_base() # subclass `FunctionRelator` for models with a relationship to Function models class Parent(FunctionRelator, Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) functions = relationship('Function', backref='parent') # subclass `FunctionMixin` to define a Function model class Function(FunctionMixin, Base): __tablename__ = 'function' id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey('parent.id')) Base.metadata.create_all(engine) We can now set the functions attribute to a callable as follows. def foo(*args, **kwargs): print('My args are', args) print('My kwargs are', kwargs) return 'return value' parent = Parent() parent.functions = foo # equivalent to: # parent.functions = [foo] # parent.functions = Function(foo) # parent.functions = [Function(foo)] parent.functions Out: [<__main__.Function object at 0x7f4e5a49c160>]","title":"Examples"}]}